11/11/2021

DC files, originally used for Disney's MMO games Toontown and Pirates and their
distributed object system, define schemas for the various distributed objects that
may manifest in the game world, such as the stateful properties and messages
that the objects may have.  Currently, serialization/deserialization of distributed
objects to/from the schema defined in the DC file is only implemented for Python
code.  We need to figure out how to be able to do this serialization/deserialization
for C++ implementations of distributed objects.  Since Python is a dynamically-typed
language, it's very easy to map DC fields and messages to attributes and methods
on a Python class.  For C++ this is more complicated, as C++ does not have any
built-in introspection or dynamic typing.

We could not use DC files at all and do something similar to Source where the .cpp
files have macros to specify the networked properties of a class.  However, I feel
that using DC files gives us several advantages.  For one, the network schema of
distributed objects and their messages are defined once, in one place, and used
by both the client and server.  Without DC files (like the Source method), how
properties and messages are encoded have to be specified in both the client and
server implementations of the object, such as the recv table and send table
both having to specify how a field is encoded on the wire, etc.  This is more
error prone.  Furthermore, having schemas defined in an isolated file is more
portable and can potentially be interpreted in a different environment, which
would not be possible if the schemas are defined in the C++ code itself.  For
example, the OTP server would use the same DC file as the client and AI to be
able to store the state of distributed objects on the state server.  This was
also the case for long-term database storage of `db` fields.  Finally, using
the DC syntax to define distributed object schemas is a lot more elegant than
C++ macros.  The DC syntax has many features to control network encoding of
fields and specify behavioral attributes.

To solve linking C++ classes to dclasses and fields to members, we need to
associate metadata with the C++ class that can be accessed via a global
registry in the distributed system.  We need to specify: the class name,
base class name(s), names of attributes and their data types.  This would
basically be a reflection system.  During static initialization we would build
up this registry of classes and their contained fields.  Each field must store
the byte offset from the beginning of the class structure of where the memory
for the field begins, so we can read and write the data.
